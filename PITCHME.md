### The Simple Essence of Automatic Differentiation
Conal Elliott (March, 2018)
[https://arxiv.org/abs/1804.00746](https://arxiv.org/abs/1804.00746)  

An informed and possibly incorrect recap of Conal's ICFP 2018 talk.
---
### Background
- Automatic differentiation (AD):
    - Derivatives of mathematical(ish) functions generated by the compiler/interpreter
    - Derivatives useful for numerical optimization (backbone of ML), incremental computation, and other cool things
    - More exact, efficient, (and often) numerically stable than finite-difference calulation
- Usually based on computation DAG and propagation of error terms via stateful constructs - difficult to parallelize  
---
### Broad Idea
- At a higher level of abstraction, a derivative is a **linear map** rather than just a number/vector/matrix/tensor.
- Languages that can represent these concepts in a first-class way are suited for this interpretation of AD
---
### Warning
Abuse of syntax ahead!
---
- Derivatives of ***linear*** functions are *identi*cal to the functions themselves: For all linear functions `f`, `D f a = f`  
```OCaml
val f : 'a -> 'b
val D : ('a -> 'b) -> 'a -> ('a -> 'b)
```
- Derivatives composition (chain rule): `D (g f) a = (D g (f a)) (D f a)`
```OCaml
val f : 'a -> 'b
val g : 'b -> 'c
typeof{D f a} : 'a -> 'b
typeof{(D g (f a))} : 'b -> 'c
```
- Doesn't really compose sequentially: `D (g f)` can't be expressed in terms of just `D g` and `D f`.
---
- Define one that does compose sequentially:
```OCaml
val f : 'a -> 'b
val D' : ('a -> 'b) -> ('a -> 'b * ('a -> ('a -> 'b))) 
(* carry the original function along *)
let D' f a = (f a, D f a)
(* when defined like this, we get the composition: *)
D' (g f) a =
  ((g f) a, D (g f) a)
  (* or by composition of functions *)
  (g (f a), D (g f) a)
  (* or by chain rule *)
  (g (f a), (D g (f a)) (D f a))
```
---
```
  (* continued... *)
  (g (f a), (D g (f a)) (D f a))
  (* refactor to share [f a] *)
  let b = f a in (g b, (D g b) (D f a))
  (* refactor to show composition *)
  let (b, f') = D' f a in
  let (c, g') = D' g b in
  (c,g' f')
```
- Once you have an identity and a composition, this forms a category
---
### Contributions
- Develops an approach to AD independent of data structure representation of computation graph (Wegner lists or tapes etc.)
- Builds on previous work - "Compiling to categories", any simply-typed lambda calculus can be compiled down to a category (interpreted as a category).
- Compiler plugin compiles down to categories and the 'arrows' can be interpreted as one chooses, to extract an efficient representation for computation of derivatives.
---
- Unifies reverse-mode AD as a special case (left-association of sequential composition equivalent to continuation-passing style), providing potential for parallelizable implementations
- Bridges symbolic differentiation and automatic differentiation as being the same thing in a functional language
---
### Links
- Video of talk: https://www.youtube.com/watch?v=MmkNSsGAZhw
- Paper: https://arxiv.org/abs/1804.00746
- Video of "Compiling to categories": https://www.youtube.com/watch?v=SVRYcrhRCes
- Paper: http://conal.net/papers/compiling-to-categories/compiling-to-categories.pdf
